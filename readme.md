# LRU Cache
[![Version](https://img.shields.io/crates/v/lru-cache-rs)](https://crates.io/crates/lru-cache-rs)
[![License](https://img.shields.io/crates/l/lru-cache-rs)](License)


# Кеш LRU на Rust

Высокопроизводительная реализация кеша с алгоритмом вытеснения LRU (Least Recently Used) и поддержкой времени жизни записей.

## Возможности

- **Алгоритм LRU**: Автоматическое вытеснение редко используемых элементов при заполнении кеша
- **Время жизни записей (TTL)**: Опциональное ограничение времени хранения элементов
- **O(1) сложность операций**: Вставка и получение за константное время
- **Безопасная работа с памятью**: Использование `Box` и `NonNull` для управления памятью
- **Обобщённая реализация**: Работает с любыми типами ключей (`K: Eq + Hash + Clone`) и значений (`V`)

## Базовое использование

```rust
use lru_cache_rs::LruCache;
use std::time::Duration;

let mut cache = LruCache::new(2); // Создаём кеш ёмкостью 2 элемента

// Добавляем значения
cache.put("a", 1, None); // Без ограничения времени
cache.put("b", 2, Some(Duration::from_secs(1))); // С временем жизни 1 секунда

// Получаем значения
assert_eq!(cache.get(&"a"), Some(&1));
assert_eq!(cache.get(&"b"), Some(&2));

// Вытеснение по LRU
cache.put("c", 3, None); // Вытеснит "a", если он использовался давнее всех
```

## Основные методы

### Основные операции

- `new(capacity: usize) -> Self` - Создание нового кеша указанной ёмкости
- `put(key: K, value: V, ttl: Option<Duration>)` - Добавление элемента
- `get(&key: &K) -> Option<&V>` - Получение элемента (неизменяемая ссылка)
- `get_mut(&key: &K) -> Option<&mut V>` - Получение элемента (изменяемая ссылка)

### Вспомогательные методы

- `len() -> usize` - Текущее количество элементов
- `is_empty() -> bool` - Проверка на пустоту
- `capacity() -> usize` - Максимальная ёмкость кеша

## Производительность

- Все операции (добавление/получение) выполняются за O(1)
- Используется HashMap для быстрого поиска и двусвязный список для управления порядком
